本周学习了归并排序法  
首先递归，可以很明显看出，递归是从第一个函数一层一层执行下去，直至变为一个元素再在执行第二个函数，再次生成单元素数组；  
执行第三个函数合并数组，重复，直至到函数执行结束。  
在合并函数中，第二个和第三个循环是用来将未存入临时数组的数据存入，因为是有序数组，所以只存在一个数组为完全存入，且数据已完成排序，即之后元素之直接复制就好，不在需要任何操作。  
则这两个循环可以互调位置，不影响程序结果。  
归并排序的是按照分层进行比较的，会分成log 2n层 ;  
而每一层的比较次数为O ( n ) ；  
所以时间复杂度求得O ( nlogn ) 。  
起初的tmp数组创建的目的：开辟与原数组一样大的一块空间，因为后面要给数组赋值，如果数组没有这么大，赋值就会出错，比如int arr[]={};arr[1]=10;此时就会报错；  
在进入merge操作的时候，每次进入都需要拷贝一次数组，因为arr在每次判断之后的值已经发生改变，所以要及时更新tmp数组的值  ；  
归并排序法的空间复杂度为O(n)需要借助额外的辅助空间才能进行排序。
